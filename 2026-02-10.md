# 2026-02-10

# Good Morning - it's **Tuesday, February 10, 2026**.

## Getting into your VMs:

- Go to https://class.hypertheory-labs.dev/guacamole
- Enter your student number as the username (e.g. "student16")
- Use the password you set yesterday.

If you have any issues, LMK

## Today

> Major Theme - Write Code!

- Review how to get my code 
  - Note - I added some notes - you can copy the whole `jeff-notes` folder, or just pick the things you want and add them to your notes.
  - I added in `src/week1/MuddiestMomentSolution/` a folder called `frontend` - this has the very starting stuff for an Angular app. Copy it. We'll use it later.
- The part where the instructor vows to be clearer about when to code with him, or when to relax and pull my code.
- Review the code from EOD yesterday
  - In order to have our app, we are going to need several things running on our machine, things our app will interact with.
    - A database
    - An IDP
    - Our API
    - The frontend (later)
  - These things are called "Backing Services" (think of them like backup singers - they need them, but we are focused on the lead - our app)
  - It is *best* if we can run all this stuff locally - but we can't always do that. I can't always do that.
    - Sometimes you'll need to access other backing services
  - The Aspire AppHost is responsible for getting all of this running, and even installed if we have containers and stuff.
  - Needs a "Container Runtime"
    - **Start Docker Desktop**
  - Define our backing services in AppHost
    - Database
      - Kind? Version?
      - Schema?
      - Is this "close enough" to the production database?
        - "Our team owns the database, we decide what tables, column types, etc. are in there, and no other application uses this data"
        - Versus: "It is a shared database, passed around like a cheap bottle of wine at a fire pit. Other teams modify the schema, mess with the data, etc."
        - Which is better?
        - We are coupling to: a version, a schema we control, a specific "flavor" of SQL, etc.
      - [ ] Define our Database
    - Identity
      - What we need: We *know* another team has the ability to validate (Authenticate) users, and they do an amazing job.
      - We send the user to their service. If that team is satisfied, they send them back to us with a golden ticket (a token). 
      - We have a way to verify the token was provided by the team that handles identity (we have a secret we share!)
      - "Published Language": OIDC/Oauth2 
      - Based on that, we can *authorize* users to do certain things within our application
        - e.g. You can delete or edit your "moments", but not other users.
        - If you are the instructor, you can see a list of *all* the students moments
        - etc.
      - [ ] Define our IDP (note: We may not use this until later)
    - Build Our App
      - We can start with either the frontend or the backend. I often iterate between the two.
      - For now, we are going to stick to the backend.



  ## Services

  Code or Code Thingies that own some data and all the process around that data.

  (this is a version of the definition given by Dr. Alan Kay when somebody asked him what "Object Oriented" means.)